# 2장 분할정복

Class: PARK 264
Created: Jul 16, 2020 3:55 PM
Materials: https://github.com/ParkGunWook/TBD/tree/master/2%EC%9E%A5/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
Property 1: 건욱 박
Type: Section

# 분할정복?

---

알고리즘 설계 기법으로서 처음으로 다룰 것은 분할정복이다.

분할정복은 문제의 입력사례에 적용하여 문제를 풀어낸다. 즉, 문제의 입력사례를 두 개 이상의 작은 입력사례로 분할한다. 분할한 입력사례의 정답을
바로 얻을수 있으면, 원래 문제의 답은 얻은 답들을 통합하여 구할 수 있다. 분할한 입력사례가 여전히 커서 바로 답을 구하지 못하면 그보다 더 작은
입력사례로 다시 분할한다. 바로 답을 구할 수 있을 만큼 충분히 작아질 떄까지 입력사례를 계속 분할한다.

분할정복은 하향식 문제풀이 방식이다. 즉 문제의 상위 입력사례의 해답은 하위의 작은 입력사례의 해답을 가지고 구한다. 재귀함수가 작동하는 원리가
바로 이렇다. 문제풀이 중심으로 재귀함수를 작성하고, 해답을 어떻게 얻는지에 대한 세부사항은 시스템이 알아서 하도록 맡긴다.
분할정복 알고리즘을 설계할때도 보통 이런 식으로 사고하고, 알고리즘을 재귀로 작성한다. 후에 재귀 알고리즘은 효율적인 반복 알고리즘으로
변형할 수 있다.

---

### 설계 방법

---

1. 문제의 입력사례를 하나 이상의 작은 입력사례로 분할한다.
2. 작은 입력사례들을 각각 정복한다. 작은 입력사례가 충분히 작지 않으면 재귀 호출한다.
3. 필요하다면, 작은 입력사례의 해답을 통합하여 원래 입력사례의 해답을 구한다.

---

## 2.1 이분검색

### 1. 특징

알고리즘 1.5는 반복을 이용한 이분검색 알고리즘이었다. 재귀 함수의 재귀 호출은 분할정복의 하향식 문제풀이 방식과 원리가 같다. 이번에는 이분검색 알고리즘을 재귀로 설계할 것이다.
재귀로 설계한 이유는 입력사례를 더 작은 입력사례들로 분할하는 분할정복 절차를 분명하게 설명해주기 때문이다.
분할정복 알고리즘 중에서 가장 간단한 부류에 속한다. 왜냐하면 입력 사례를 분할하여 해답을 구하고, 결과를 취합할 필요가 없기 때문이다.

### 2. 알고리즘 절차

1. [분할] 배열을 정 가운데 원소를 기준으로 반으로 분할한다. x가 가운데 원소보다 작으면 왼쪽 배열을 선택한다. x가 가운데 원소보다 크면 오른쪽
배열을 선택한다. x가 가운데 원소보다 크면 오른쪽 배열을 선택한다.
2. [정복] 선택한 반쪽 배열을 정복한다. 즉, 선택한 반쪽 배열에 x가 있는지 재귀적으로 이분검색한다.
3. [취합] 선택한 반쪽 배열에서 얻은 답이 최종 답이다.

### 3. 알고리즘

- 문제 : 원소가 n개인 정렬된 배열 S에 검색키 x가 있는가?
- 입력 : 양의 정수 n, 정렬된 배열 S, 검색키 x
- 출력 : location, S에서 x의 위치(x가 없다면 0을 출력)

### 4. 분석

배열의 검색 알고리즘에서 가장 큰 비용이 드는 함수는 검색키와 배열 원소를 비교하는 연산이다.

단위연산 : x와 x[mid]의 비교
입력크기 : 배열 원소의 개수, n

최악의 경우가 배열의 어떤 원소보다도 큰 경우이다. n이 2의 거듭제곱이고 배열의 어떤 원소보다 크면, 재귀 호출을 할 때마다 입력사례의 크기가 반으로 줄어든다.
예를 들어, n=16이면, 두번째 mid=8이다. 그리고 다음 호출의 입력은 4가 될 것이다. 결과적으로 재현식은 $W(n) = W(n/2) +1$ 으로 나오게 될 것이다.

재현식의 해답은 $W(n) = log(n)+1$ 이 될 것이다.

### 5. 의사코드

```cpp
int location(int low, int high)
{
	int mid;

	if(low > high)
		return 0;
	else {
		mid = (low + high ) / 2;
		if(x == S[mid])
			return mid;
		else if( x < S[mid)
			return location(low, mid-1);
		else
			return location(mid+1, high);
} 
```

## 2.2 합병정렬

---

### 1. 특징

쌍방 합병이란 정렬된 배열 두 개를 정렬상태를 유지하면서 하나로 합치는 것이다. 합병을 이용하여 임의의 배열을 정렬할 수 있다.

### 2. 알고리즘 절차

1. 분할 : 배열을 반으로 분할한다. 분할한 배열의 원소는 각각 n/2개이다.
2. 정복 : 분할한 배열을 각각 따로 정렬한다.(배열에 원소가 2개 이상이면 합병정렬을 재귀 호출하여 정렬한다.
3. 취합 : 정렬한 두 배열을 합병하여 정렬한다.

![2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%202842b4db1e8e41d3bcbbbc4d4f536abc.gif](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%202842b4db1e8e41d3bcbbbc4d4f536abc.gif)

수동 실행 예시 출처 : **[https://gfycat.com/ko/soulfulhiddendog](https://gfycat.com/ko/soulfulhiddendog)**

### 3. 알고리즘

**3.1 합병 정렬**

- 문제 : n개 원소를 비내림차순으로 정렬
- 입력 : 양의 정수 n, 배열 S(인덱스는 1부터 n까지)
- 출력 : 원소를 비내림차순으로 정렬한 배열 S

**3.2 합병**

- 문제 : 정렬된 배열 두개를 정렬상태를 유지하면서 하나로 합병
- 입력 : 양의 정수 h와 m, 정렬된 배열 U(인덱스는 1부터 h까지), 정렬된 배열 V(인덱스는 1부터 m까지)
- 출력 : U와 V의 원소를 모두 포함하여 정렬한 배열 S

### 4. 분석

**4.1 합병의 최악 시간복잡도 분석**

- 단위연산 : U[i]와 V[j]의 비교
- 입력크기 : 두 입력 배열의 원소 개수, h와 m

최악의 경우는 i = h+1 이고 j = m인 상태에서 루프를 빠져나가는 경우이다. 예를 들면, V의 앞 m-1개 원소는 모두 S로 먼저 옮기고 U의 h개 원소를 모두 S로 옮긴 직후 이런 상황이 발생한다. 따라서 W(h,m) = h+m-1이다.

**4.2 합병정렬의 최악 시간복잡도 분석**

- 단위연산 : merge에서 일어나는 비교연산
- 입력크기 : 배열 S의 아이템 수, n

총 비교 횟수는 U를 입력으로 *mergesort*를 재귀 호출하는데 실행하는 비교연산의 횟수와 V를 입력으로 *mergesort*를 재귀 호출하는데 실행하는 비교연산의 횟수와 *merge*를 호출하여 실행하는 비교연산의 횟수의 합이다. 따라서 다음과 같다.

**제자리 정렬**은 입력을 저장하는데 필요한 장소 이외의 추가적인 저장장소를 사용하지 않는 정렬 알고리즘이다. 하지만 합병정렬은 U와 V라는 추가적인 저장장소를 사용하기 때문이다. 만약 *merge*에서 U와 V를 주소로만 전달한다면 배열의 사본을 만들 필요는 없다. 그러나 mergesort를 호출할 때 마다 배열 U와 V를 새로 만들어야 한다. 맨 처음 호출할 때 이 두 배열의 원소 개수 합은 대략 n이고, 다음에는 n/2개, 그 다음은 n/4개일 것이다. 그래서 총 2n 정도의 추가적인 배열 원소가 만들어지게된다.

$W(n) = W(h)  + W(m) + h+m-1$

$h = \lfloor n/2 \rfloor$ 

$m = n -h = n- \frac n 2 = \frac n 2$

$h + m = \frac n 2 + \frac n 2 = n$

**4.3 재현식**

$W(n) = W(\frac n 2) + W(\frac n 2) + n - 1 = 2 W(\frac n 2) + n - 1$

$W(n) = n log (n) - (n-1)$

$W(n) \sub \bigodot(n log (n))$

### 5. 의사코드

5.1 합병정렬

```cpp
void mergesort(int n, vector<int> S)
{
	if(S.size() > 1){
		const int h = n/2, m = n - h;
		vector<int> U(h), V(m);
		copy(S.begin(), S[h], U)
		copy(V.begin(), V[h], V)
		mergesort(h, U);
		mergesort(m, V);
	}
}
```

5.2 합병

```cpp
void merge(int h, int m, const vector<int> U, const vector<int> V)
{
	int i, j, k;
	i=1, j=1, k=1;
	while(i <= h && j <= m){
		if(U[i] < V[j]) {
			S[k] = U[i];
			i++;
		}
		else {
			S[k] = V[j];
			j++;
		}
		k++;
	}
}
```

## 2.3 빠른정렬(분할교환정렬)

---

### 1. 특징

호아(Hoare, 1962)가 고안한 "빠른정렬(Quicksort)"이라는 정렬 알고리즘이다. 빠른정렬은 배열을 둘로 분할하고, 분할한 배열을 각각 재귀 호출로 (recursively) 정렬하여 합병하므로 합병정렬과 비슷하다. 그러나 빠른정렬은 배열을 분할하는 방식이 다르다.

![2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%202842b4db1e8e41d3bcbbbc4d4f536abc/_wiki.gif](2%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%202842b4db1e8e41d3bcbbbc4d4f536abc/_wiki.gif)

수동 실행 예제  출처 - [https://commons.wikimedia.org/wiki/File:Quicksort-example.gif](https://commons.wikimedia.org/wiki/File:Quicksort-example.gif)

### 2. 알고리즘

**2.1 빠른정렬**

- 문제 : 비내림차순으로 원소가 n개인 배열을 정렬
- 양입력 : 의 정수 n, 배열 S(인덱스는 1부터 n까지)
- 출력 : 비내림차순으로 정렬된 배열 S

**2.2 분할**

- 문제 : 빠른정렬에서 쓸 수 있도록 배열 S를 분할
- 입력 : 인덱스 low와 high, 배열 S에서 low부터 high까지의 부분배열
- 출력 : low부터 high까지 인덱스로 된 S의 부분배열의 기준점, pivotpoint

### 3. 분석

**3.1 분할의 일정 시간복잡도 분석**

- 단위연산 : S[i]와 pivotitem의 비교
- 입력크기 : n = high-low+1(부분배열 원소의 개수)

    $T(n) = n-1$

    여기서 n은 전체배열 S의 크기가 아니라 부분배열의 크기를 나타낸다. partition을 처음 호출했을 때만 n은 S의 크기와 같다.

**3.2 빠른정렬의 최악 시간복잡도 분석**

- 단위연산 : *partiotion*에서 S[i]와 *pivotitem*의 비교
- 입력크기 : n (배열 S 원소의 개수)

    완전히 정렬된 배열을 정렬하는 경우가 최악의 경우이다. 이유는 완젼히 정렬되어 있으면, 첫째(기준)보다 작은 아이템은 없다. 따라서 partiotion을 처음 호출할 때 기준원소 왼쪽으로 보낼 원소는 하나도 없고, pivotpoint의 값은 1이 된다. 재귀 호출할 때 마다 pivotpoint는 low 값을 받는다.

    $T(n) = T(0) + T(n-1) + n-1$

    따라서 재현식은  $T(n) = \frac {n(n-1)} 2$ 이다.

**3.3 빠른정렬의 평균 시간복잡도 분석**

- 단위연산 : partition에서 S[i]와 pivotitem의 비교
- 입력크기 : n(배열 S에서 원소의 개수)

증명은 미래에 합시다.

### 5. 의사코드

**5.1 빠른정렬**

```cpp
void quicksort(int low, int high)
{
	int pivotpoint;
	if(high > low){
		partition(low, high, pivotpoint);
		quicksort(low, pivotpoiont - 1);
		quicksort(pivotpoint +1, high);
	}
}
```

**5.2 분할**

```cpp
void partition(int low, int high, int& pivotpoint)
{
	int i, j;
	int *pivotitem;
	pivotitem =S[low];
	j = low;
	for(i = low+1; i<=high; i++)
		if(S[i] < pivotitem){
			j++;
			swap S[i] and S[j];
		}
	pivotpoint = j;
	exchange S[low] and S[pivotpoint];
}
```

## 2.4 쉬트라쏀의 행렬곱셈 알고리즘

---

### 1. 특징

1장에서 하였던 행렬곱셈은 정의를 그대로 따라 두 행렬을 곱하였다. 곱셈 횟수를 기준으로 구한 시간복잡도는 n이 행렬에서 열과 행의 개수일 때 $T(n) = n^3$ 임을 증명하였다. 알고리즘을 약간 변형시켜 덧셈 횟수를 기준으로 분석하면 시간복잡도는 $T(n) = n^3 - n^2$ 이다. 모두 시간 복잡도가 $\bigodot(n^3)$ 이므로 조금만 커져도 의미가 없다.

### 2. 예시

두개의 2 X 2 행렬 A와 B의 곱(product)인 C를 구한다고 가정한다.

$\begin {bmatrix}
 c_{11} && c_{12} \\
 c_{21} && c_{22}
\end {bmatrix} =
\begin {bmatrix}
 a_{11} && a_{12} \\
 a_{21} && a_{22}
\end {bmatrix} +
\begin {bmatrix}
 b_{11} && b_{12} \\
 b_{21} && b_{22}
\end {bmatrix}$

$m_1 = (a_{11} + a_{22})(b_{11} + b_{22})$

$m_2 = (a_{21} + a_{22}) * b_{11}$

$m_3 = (a_{11}) * (b_{12} - b_{22})$

$m_4 = (a_{22}) * (b_{21} - b_{11})$

$m_5 = (a_{11} + a_{12}) * b_{22}$

$m_6 = (a_{21} - a_{11})(b_{11} + b_{12})$

$m_7 = (a_{12} - a_{11})(b_{21} + b_{22})$

곱 C는 다음과 같다

$C = \begin {bmatrix}
 m_{1} + m_{4} -m_{5}+m_{7} && m_{3} + m_{5} \\
 m_{2} + m_{4} && m_{1} + m_{3} - m_{2} + m_{6}
\end {bmatrix}$

### 3. 의사코드

3.1 쉬트라쏀

- 문제 : n인 2의 거듭제곱일 때 2개의 n*n 행렬의 곱을 구하시오
- 입력 : 2의 거듭제곱인 정수 n, 2개의 n*n 행렬 A와 B

```cpp
void strassen(int n, n*n_matrix A, n*n_matrix B, n*n_matrix& C)
{
	if(n<= threshold)
		표준 알고리즘으로 C= A X B를 계산한다.;
	else{
		A를 4개의 행렬로 분할한다.;
		B를 4개의 행렬로 분할한다.;
		쉬트라쏀의 방법으로 C=A*B를 계산한다.;
		// 재귀 호출의 예제
		// strassen(n/2, A_11 + A_22, B_11 + B_22, M_1);
	}
}
```

### 4. 분석

4.1 쉬트라쏀에서 곱셈의 수의 일정 시간복잡도 분석

- 단위연산 : 곱셈 1회
- 입력크기 : n (행렬에서 행과 열의 수)

분석절차를 간단하게 하기 위해서 2개의 1*1 행렬이 될떄까지 계속 나누는 경우를 분석한다. 

재현식은

$T(n) = 7 T(\frac n 2), (n>1이며, n은 2의 거듭제곱)$

$T(n) = n^{log7} = n^{2.81} \sub \bigodot(n^{2.81})$

## 2.5 큰 정수 계산법

---

### 1. 특징

정수를 표현하는 저장공간의 용량을 초과하는 정수 연산을 해야 한다고 하자. 만약 유효숫자를 모두 보존해야 한다면, 부동소수점으로 표현을 바꾸어 연산을 해도 소용이 없다. 이 경우 유일한 대안은 소프트웨어로 정수를 표현하고 처리해야 한다. 분할정복의 도움을 받아서 이를 성사할 수 있다. 

1.1 큰 정수 표현 : 덧셈과 기타 1차 시간 연산

가장 직관적인 방법은 숫자 배열을 사용하는 것이다. 예를 들면, 정수 153,127은 다음과 같이 배열 S로 표현이 가능하다.

$\frac 1 {S[6]} \frac 5 {S[5]} \frac 3 {S[4]} \frac 2 {S[3]} \frac 1 {S[2]} \frac 7 {S[1]}$

양수와 음수를 표현하는 것은 하나의 슬롯을 추가 하면 될 것이다. 그리고 큰 정수를 표현하기에 충분한 배열이라고 가정하겠다. n을 큰 정수 숫자 개수라고 하면 덧셈과 뺄셈을 하는 1차시간 알고리즘을 작성하는건 간단할 것이다.

1.2 큰 정수 곱셈

큰 정수를 곱하는 간단한 2차시간 알고리즘은 초등학교에서 배웠을 수도 있는 방법을 그대로 쓸 것이다.

$567832 = 567 * 10^3 + 832$

$9423723 = 9423 * 10^3 + 723$

일반적으로 n을 정수 u에 있는 숫자의 개수라고 하면, 그 정수 u를 다음과 같이 하나는 크기가 $\lceil \frac n 2 \rceil$이고 다른 하나는 $\lfloor \frac n 2 \rfloor$인 두개의 정수로 분할한다.

이렇게 n개의 숫자로 이루어진 두 정수가 있다면 다음과 같은 식을 구성해낼 수 있다.

$u = x \times 10^m + y$

$v = w \times 10^m +z$

그 곱은 다음과 같다.

$uv =(x \times 10^m +y)(w \times 10^m +z) = xw \times 10^{2m} +(xz +wy) \times 10^m + yz$ 

길이가 반 정도인 정수를 네 번 곱하고, 1차시간 연산을  실행하여 u와 v를 곱한다.

### 2. 알고리즘

2.1 큰 정수 곱셈 / 큰 정수 곱셈 2

- 문제 : 2개의 큰 정수 u와 v를 곱함
- 입력 : 큰 정수 u와 v
- 출력 : u와 v의 곱

### 3. 의사코드

3.1 큰 정수 곱셈

```cpp
large_integer prod (large_integer u, large_integer v)
{
	large integer x, y, w, z;
	int n, m
	n = max(u.size(), v.size())
	if( u == 0 || v == 0) return 0;
	else if( n<= Threshold) return u*v;
	else {
		m = floor(n/2);
		x = u / pow(10,m);
		w = v / pow(10,m);
		y = u % pow(10,m);
		z = v % pow(10,m);
		return prod(x,y)*pow(10,2m) + (prod(w,y) + prod(x,z)) * pow(10,m) + prod(y,z);
	}
} 
```

3.2 큰정수 곱셈2

```cpp
large_integer prod2 (large_integer u, large_integer v)
{
	large integer x, y, w, z;
	int n, m
	n = max(u.size(), v.size())
	if( u == 0 || v == 0) return 0;
	else if( n<= Threshold) return u*v;
	else {
		m = floor(n/2);
		x = u / pow(10,m);
		w = v / pow(10,m);
		y = u % pow(10,m);
		z = v % pow(10,m);
		r = prod2(x+y, w+z);
		p = prod2(x,w);
		q = prod2(y,z)
		return p*pow(10,2m) + (r-p-q) * pow(10,m) + q;
	}
} 
```

### 4. 분석

4.1 큰 정수 곱셈의 최악 시간복잡도 분석

- 단위연산 : +, -, /, %, * 를 계산 할때(뒤의 3가지 연산은 실행횟수가 m이다.) 큰 정수에서 한자리 십진수 곱셈,
- 입력크기 : n(두 정수 각각의 숫자 개수

최악의 경우는 두 정수 모두 0과 같은 숫자가 없는 경우이다. 왜냐하면, 임계점을 지나야만 재귀 호출이 끝나기 때문이다. 이 경우를 분석해보자.

n을 2의 거듭제곱이라고 가정하자. 그러면 x,y,w,z는 모두 정확하게 숫자의 개수가 n/2이다. 그러면 4개의 재귀 호출에 각각에 주어지는 입력의 크기는 n/2이다. m=n/2이기 때문에, 덧셈, 뺄셈, 나누기, 나머지, 곱하기의 연산은 모두 n에 대해서 1차시간이다. 1차 시간 연산들은 각각의 크기가 다르기 떄문에 1차시간 연산을 모두 하나의 항 cn으로 묶어서 계산하겠다. 재현식은 다음과 같다.

$W(n) = 4W(\frac n 2) + cn, n>s, n은 2의 거듭제곱$

$W(s) = 0$

더 이상 입력사례를 분할하지 않는 지점의 실제 값 s는 임계점  값보다 작거나 같고 2의 거듭제곱이다. 왜냐하면, 여기서 입력은 모두 2의 거듭제곱이라고 가정했기 때문이다. 2의 거듭제곱이 아닌 n에 대해서는 앞의 방정식과 비슷하지만 내림수연산과 올림수연산을 포함한 재현식으로 작성가능하다.

그렇게 해서 $W(n) \sub \bigodot(n^{log4})  = \bigodot(n^2)$으로 의미가 없음을 알 수 있다.

4.2 큰 정수 곱셈2의 최악 시간복잡도 분석

- 단위연산 : +, -, /, %, * 를 계산 할때(뒤의 3가지 연산은 실행횟수가 m이다.) 큰 정수에서 한자리 십진수 곱셈,
- 입력크기 : n(두 정수 각각의 숫자 개수

최악의 경우는 위와 같다. 

[큰 정수 곱셈2의 x+y에서 숫자 개수의 예](https://www.notion.so/4271a7738f3649c29cc6d61a5106e34c)

n이 2의 거듭제곱이라면, x, y, w, z는 모두 숫자의 개수가 n/2이다. 그러므로 위의 표에서 보듯이 다음과 같은 부등식을 얻을 수 있다.

$\frac n 2 \leq x+y에서 숫자의 개수 \leq \frac n 2 +1$

$\frac n 2 \leq w+z에서 숫자의 개수 \leq \frac n 2 +1$

이로서 우리는 각 함수 호출에 대해서 입력크기가 다음과 같이 된다는 것을 의미한다.

[Untitled](https://www.notion.so/c7bb4f29f9a54fb98e58674146d80744)

m= n/2이기 때문에, 우리는 덧셈, 뺄셈, 나누기, 나머지, 곱하기와 같은 1차시간 연산은 모두 n에 대해서 시간 복잡도가 1차시간이다. 그러므로 W(n)은 다음을 만족한다.

$3W(\frac n 2) + cn \leq W(n) \leq 3W(\frac n 2 +1) +cn, n>s이며 n이 2의 거듭제곱$

$W(s) =0$

따라서 $W(n) \sub \Omega (n^{log_2 3}) \sub \bigodot(n^{1.58})$ 임을 알 수 있다.

# 2.6 분할정복법을 사용할 수 없는 경우

---

1. **크기 n인 사례가 거의 n에 가까운 크기의 두 개 이상의 사례로 분할된다.**
2. **크기 n인 사례가 n/c 크기의 거의 n개 사례로 분할된다.**

첫 번쨰와 같이 분할하면 지수시간 알고리즘이 나오고, 두번째와 같이 분할하면 $n^{\bigodot(log(n))}$알고리즘이 나온다. 이중 어떤 것도 n값이 크면 받아들일 수 없다. 왜 그렇게 분할하면 성능이 나빠지는가는 직관적으로 봐도 알 수 있다. 예를 들어서 재귀적인 방법의 피보나치 항이 n-1과 n-2를 계산하는 두 개의 사례로 분할하는 정복법이 1번의 나쁜 예시라고 볼 수 있다. 반면 때로는 지수 시간으로 문제를 풀어도 되는 경우가 있는데, 그 경우는 하노이탑 같은 경우가 있을 것이고 하노이탑의 최적 시간은 고정되어 있기 때문이기도 하다.